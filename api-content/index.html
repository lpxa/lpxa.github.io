{"posts":[{"title":"仿学生管理系统","content":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct _node { char name[64]; char id[10]; char score[64]; struct _node *next; } Node; typedef struct _list { Node *head; } List; //--1--插入新的学生(头插法) void AddStudentByHead(List *list); //尾插法V1 void AddStudentByEndV1(List *list); //尾插法V2只能单独使用 void AddStudentByEndV2(List *list); void ChangeStudent(List *list, char *input); void Input(Node *p); int Search(List *list, char *input); void Delete(List *list, char *input); void PrintStudent(List *list); void ClearList(List *list); Node *PrintFlage(List *list, char *input); int main(void) { List list; list.head = NULL; char code; int c; char input1[64]; char input2[64]; char input3[64]; int flag = 0; Node *temp; while (1) { ​ printf(&quot;欢迎使用学生成绩管理系统\\n&quot;); ​ printf(&quot;----1.插入新的学生-----\\n&quot;); ​ printf(&quot;----2.查找已有学生----\\n&quot;); ​ printf(&quot;----3.更改学生--------\\n&quot;); ​ printf(&quot;----4.删除已有学生----\\n&quot;); ​ printf(&quot;----5.显示已有学生----\\n&quot;); ​ printf(&quot;----6.退出系统-------\\n&quot;); ​ printf(&quot;请输入指令代码(1-6)\\n&quot;); ​ do ​ { ​ scanf(&quot;%c&quot;, &amp;code); ​ } while (code&gt;54||code&lt;49); ​ ​ switch (code) ​ { ​ case '1': ​ printf(&quot;请选择插入学生的方法(1-头插法 2-尾插法V1)😊; ​ scanf(&quot;%d&quot;, &amp;c); ​ switch (c) ​ { ​ case 1: ​ AddStudentByHead(&amp;list); ​ break; ​ case 2: ​ AddStudentByEndV1(&amp;list); ​ break; ​ default: ​ printf(&quot;输入指令错误\\n&quot;); ​ } ​ break; ​ case '2': ​ printf(&quot;请输入你要查找的学生:&quot;); ​ scanf(&quot;%s&quot;, input1); ​ flag = (Search(&amp;list, input1)); ​ if (flag &gt; 0) ​ { ​ temp = PrintFlage(&amp;list, input1); ​ printf(&quot;学生姓名:%s\\t学号%s\\t分数:%s\\t&quot;, temp-&gt;name, temp-&gt;id, temp-&gt;score); ​ } ​ else ​ { ​ printf(&quot;不好意思,查无此人\\n&quot;); ​ } ​ break; ​ case '3': ​ printf(&quot;请输入你要更改的学生名字:&quot;); ​ scanf(&quot;%s&quot;, input2); ​ flag = Search(&amp;list, input2); ​ temp = PrintFlage(&amp;list, input2); ​ if (flag &gt; 0) ​ { ​ printf(&quot;当前的学生信息为:\\n&quot;); ​ printf(&quot;学生姓名:%s\\t学号%s\\t分数:%s\\t&quot;, temp-&gt;name, temp-&gt;id, temp-&gt;score); ​ printf(&quot;请输入您要更改的学生信息\\n&quot;); ​ ChangeStudent(&amp;list, input2); ​ } ​ else ​ { ​ printf(&quot;不好意思,你要更改的学生名字尚未存在\\n&quot;); ​ } ​ break; ​ case '4': ​ printf(&quot;请输入你要删除的学生名字:&quot;); ​ scanf(&quot;%s&quot;, input3); ​ if (Search(&amp;list, input3) &gt; 0) ​ { ​ Delete(&amp;list, input3); ​ } ​ else ​ { ​ printf(&quot;不好意思,你要删除的学生名字尚未存在\\n&quot;); ​ } ​ break; ​ case '5': ​ PrintStudent(&amp;list); ​ break; ​ case '6': ​ if (!list.head) ​ { ​ printf(&quot;还没有信息呢\\n&quot;); ​ } ​ goto END; ​ default: ​ printf(&quot;输入指令错误\\n&quot;); ​ break; ​ } ​ printf(&quot;__\\n&quot;); ​ printf(&quot;\\n\\n&quot;); } END: ClearList(&amp;list), printf(&quot;删库跑路成功__\\n&quot;); system(&quot;pause&quot;); return 0; } //--1--插入新的学生 void AddStudentByHead(List *list) { Node *p, *temp; p = (Node *)malloc(sizeof(Node)); Input(p); if (list-&gt;head) { ​ temp = list-&gt;head; ​ list-&gt;head = p; ​ p-&gt;next = temp; } else { ​ list-&gt;head = p; ​ p-&gt;next = NULL; } } //尾插法 void AddStudentByEndV1(List *list) { Node *p; p = (Node *)malloc(sizeof(Node )); Input(p); Node *last; last = list-&gt;head; if (last) { ​ while (last-&gt;next) ​ { ​ last = last-&gt;next; ​ } ​ last-&gt;next = p; ​ p-&gt;next=NULL; } else { ​ list-&gt;head = p; ​ p-&gt;next = NULL; } } //尾插法 /* void AddStudentByEndV2(List *list) { Node *p; p = (Node *)malloc(sizeof(Node )); Input(p); static Node *tail; if (list-&gt;head) { ​ tail=list-&gt;head; ​ tail-&gt;next = p; ​ p-&gt;next = NULL; } else { ​ list-&gt;head = p; ​ p-&gt;next = NULL; } tail = p; } */ void ChangeStudent(List *list, char *input) { Node *p; for (p = list-&gt;head; p; p = p-&gt;next) { ​ if (!strcmp(p-&gt;name, input)) ​ { ​ Input(p); ​ break; ​ } } } void Input(Node *p) { printf(&quot;请输入姓名:&quot;); scanf(&quot;%s&quot;, p-&gt;name); printf(&quot;请输入学号(2位数字)😊; scanf(&quot;%s&quot;, p-&gt;id); printf(&quot;请输入学生分数(小于1000)😊; scanf(&quot;%s&quot;, p-&gt;score); } int Search(List *list, char *input) { int flag = -1; //标志 Node *p; for (p = list-&gt;head; p; p = p-&gt;next) { ​ if (!strcmp(p-&gt;name, input)) ​ { ​ flag = 1; ​ break; ​ } } return flag; } Node *PrintFlage(List *list, char *input) { Node *p; for (p = list-&gt;head; p; p = p-&gt;next) { ​ if (!strcmp(p-&gt;name, input)) ​ { ​ break; ​ } } return p; } void Delete(List *list, char *input) { Node *p, *q = NULL; for (p = list-&gt;head; p; q = p, p = p-&gt;next) { ​ if (!strcmp(p-&gt;name,input)) ​ { ​ if (q) ​ { ​ q-&gt;next = p-&gt;next; ​ ​ } ​ else ​ { ​ list-&gt;head = p-&gt;next; ​ } ​ free(p); ​ break; ​ } ​ } } void PrintStudent(List *list) { Node *p; for (p = list-&gt;head; p; p = p-&gt;next) { ​ printf(&quot;学生姓名:%s\\t学号:%s\\t分数:%s\\t\\n&quot;, p-&gt;name, p-&gt;id, p-&gt;score); } } //--6--删库跑路 void ClearList(List *list) { Node *p, *q; for (p = list-&gt;head; p; p = q) { ​ q = p-&gt;next; ​ free(p); } } ","link":"https://knightl8.club/post/fang-xue-sheng-guan-li-xi-tong/"},{"title":"每日一题总结","content":"给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 示例 1： 输入：&quot;tactcoa&quot; 输出：True 解释：排列有 &quot;tacocat&quot;、&quot;atcocta&quot;，等等 示例 2： 输入：&quot;abcda&quot; 输出：False 我的思路: 如果输入的字符串长度是偶数倍,所以每个字符的次数都是偶数倍 如果输入的字符串长度是奇数倍,最多只能有一个字符的次数是奇数倍 def f(n): if len(n)%2==0: flag = 1 d={} for i in n: d[i] = d.get(i,0)+1 for j in d.values(): if j%2==0: continue else: flag = 0 if flag: return 1 else: return 0 else: flag = 0 d={} for j in n: d[j] = d.get(j,0)+1 for i in d.values(): if i/2==0: flag=0 continue if i%2==1: flag+=1 if flag&lt;=1: return 1 else: return 0 a = input() if f(a): print(&quot;True&quot;) else: print(&quot;False&quot;) 最后一次 ","link":"https://knightl8.club/post/mei-ri-yi-ti-zong-jie/"},{"title":"1021个位数统计(15分)","content":" title: '1021个位数统计(15分)' date: 2020-03-06 14:36:37 tags: [c语言学习] published: true hideInList: false feature: isTop: false 给定一个 k 位整数 N=d**k−110k−1+⋯+d1101+d0 (0≤d**i≤9, i=0,⋯,k−1, d**k−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式： 每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式： 对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例： 100311 输出样例： 0:2 1:3 3:1 我的笨办法: \\ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { ​ ​ int a[10]={0}; ​ char ch[1000]; ​ scanf(&quot;%s&quot;,ch); ​ for(int i=0;ch[i]!='\\0';i++) ​ { ​ switch(ch[i]) ​ { ​ case '0':a[0]++;break; ​ case '1':a[1]++;break; ​ case '2':a[2]++;break; ​ case '3':a[3]++;break; ​ case '4':a[4]++;break; ​ case '5':a[5]++;break; ​ case '6':a[6]++;break; ​ case '7':a[7]++;break; ​ case '8':a[8]++;break; ​ case '9':a[9]++;break; ​ } ​ ​ } ​ for(int i=0;i&lt;10;i++) ​ { ​ if(a[i]!=0) ​ { ​ printf(&quot;%d:%d\\n&quot;,i,a[i]); ​ } ​ ​ } ​ system(&quot;pause&quot;); ​ return 0; } ","link":"https://knightl8.club/post/1021-ge-wei-shu-tong-ji-15-fen/"},{"title":"数据结构","content":"什么是线性表 &quot;线性表&quot;: 由同类型数据元素构成有序序列的线性结构 表中元素个数成为线性表的长度 线性表没有元素时,称为空表 表起始位置称为表头,表结束位置称为表尾. 线性表的抽象数据类型表述 类型名称: 线性表(List) 数据对象集: 线性表是n(&gt;=0)个元素构成的有序序列(a1,a2,....an) 操作集:线性表L数与List,整数i表示位置,元素x数与ElementType 线性表基本操作主要有: 1 List MakeEmpty();初始化一个空线性表 2 ElementType FindKth(int K,List L); //根据位次序K,返回相应元素 3 int Find(ElementType X,List L); //在线性表L中查找X的第一次出现位置 4 void Insert(ElementType X,int i,List l); //在位序i前插入一个新元素X; 5 vod Delete(int i,List L); 删除指定位序i的元素 6 int Length(List L); 返回线性表L的长度n ","link":"https://knightl8.club/post/shu-ju-jie-gou/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://knightl8.club/post/hello-gridea/"}]}